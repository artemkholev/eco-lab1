# EcoLab3 - Точки подключения и события (Connection Points & Events)

## Архитектура системы

Система построена на основе механизма **Connection Points** для обработки событий, демонстрирующих пошаговую работу алгоритма сортировки Шелла (Shell Sort).

### Основные интерфейсы

- **IEcoLab1** - основной интерфейс компонента с методом ShellSort
- **IEcoConnectionPointContainer** - контейнер точек подключения
- **IEcoConnectionPoint** - точка подключения для управления соединениями
- **IEcoLab1Events** - интерфейс событий (sink interface)
- **IEcoEnumConnectionPoints** - перечислитель точек подключения
- **IEcoEnumConnections** - перечислитель активных соединений

## Реализованные события

### Интерфейс IEcoLab1Events

Для демонстрации пошаговой работы Shell sort реализованы три события:

1. **OnBeforeShellSort(array, count)** - вызывается перед началом сортировки
   - Отображает исходное состояние массива
   - Позволяет выполнить подготовительные действия

2. **ShellSortStep(array, count, gap, current_index)** - вызывается на каждом шаге сортировки
   - Параметр `gap` - текущий интервал сортировки
   - Параметр `current_index` - индекс обрабатываемого элемента
   - Демонстрирует изменение массива в процессе сортировки

3. **OnAfterShellSort(array, count)** - вызывается после завершения сортировки
   - Отображает отсортированный массив
   - Позволяет выполнить завершающие действия

## Паттерн Connection Points

### Архитектура взаимодействия

```
┌──────────────────┐         ┌───────────────────────┐
│  Client (Test)   │         │  Component (CEcoLab1) │
│                  │         │                       │
│  ┌────────────┐  │         │  ┌─────────────────┐  │
│  │ Event Sink │◄─┼─────────┼──┤ Connection      │  │
│  │ (CEcoLab1  │  │         │  │ Point           │  │
│  │  Sink)     │  │         │  │                 │  │
│  └────────────┘  │         │  └─────────────────┘  │
│        │         │         │          │            │
│        └─────────┼─────────┼──────────┘            │
│    IEcoLab1     │         │    ShellSort()         │
│    Events       │         │    fires events        │
└──────────────────┘         └───────────────────────┘
```

### Подключение Sink к компоненту

1. Получение интерфейса `IEcoConnectionPointContainer` от компонента
2. Поиск точки подключения для `IID_IEcoLab1Events`
3. Регистрация sink через метод `Advise()`
4. Получение cookie для последующего отключения
5. После работы - отключение через `Unadvise(cookie)`

## Результаты тестирования

### Демонстрация событий Shell Sort

Тестирование проводилось на массиве из 15 случайных элементов:

**Исходный массив:**
```
[21, 54, 77, 39, 28, 86, 85, 94, 86, 85, 49, 14, 35, 22, 89]
```

**Процесс сортировки:**

Алгоритм Shell sort использует последовательность gap = {7, 3, 1}

1. **Gap = 7:** Сортировка элементов на расстоянии 7
   - Элементы сравниваются и перемещаются через интервал 7
   - 9 шагов обработки

2. **Gap = 3:** Уменьшение интервала до 3
   - Более точная сортировка с меньшим интервалом
   - 12 шагов обработки

3. **Gap = 1:** Финальная сортировка (insertion sort)
   - Завершающий проход по массиву
   - 14 шагов обработки

**Отсортированный массив:**
```
[14, 21, 22, 28, 35, 39, 49, 54, 77, 85, 85, 86, 86, 89, 94]
```

### Визуализация событий

Каждое событие отображается с цветовым кодированием:
- **Красный фон** - OnBeforeShellSort (исходный массив)
- **Синий фон** - ShellSortStep (текущий шаг с gap и индексом)
- **Зеленый фон** - OnAfterShellSort (отсортированный массив)

Текущий обрабатываемый элемент выделяется дополнительно.

## Технические детали реализации

### Структура CEcoLab1

```c
typedef struct CEcoLab1 {
    IEcoLab1VTbl* m_pVTblIEcoLab1;
    IEcoCalculatorXVTbl* m_pVTblIEcoCalculatorX;
    IEcoCalculatorYVTbl* m_pVTblIEcoCalculatorY;
    IEcoConnectionPointContainerVTbl* m_pVTblICPC;

    // Connection Point для событий
    CEcoLab1ConnectionPoint* m_pISinkCP;

    // Калькуляторы
    IEcoCalculatorX* m_pIEcoCalculatorX;
    IEcoCalculatorY* m_pIEcoCalculatorY;
    IEcoUnknown* m_pInnerUnknown;

    // Управление ресурсами
    uint32_t m_cRef;
    IEcoMemoryAllocator1* m_pIMem;
    IEcoSystem1* m_pISys;
    char_t* m_Name;
} CEcoLab1;
```

### Вызов событий в ShellSort

```c
static int16_t CEcoLab1_ShellSort(...) {
    // Вызов события перед началом
    CEcoLab1_Fire_OnBeforeShellSort(me, arrPrt, arrSize);

    // Основной алгоритм
    for (ssize_t gap = arrSize / 2; gap > 0; gap /= 2) {
        for (ssize_t i = gap; i < arrSize; i++) {
            // Сортировка...

            // Вызов события на каждом шаге
            CEcoLab1_Fire_ShellSortStep(me, arrPrt, arrSize, gap, i);
        }
    }

    // Вызов события после завершения
    CEcoLab1_Fire_OnAfterShellSort(me, arrPrt, arrSize);
}
```

### Реализация Fire методов

Каждый Fire метод перебирает все подключенные sink'и и вызывает соответствующее событие:

```c
int16_t CEcoLab1_Fire_ShellSortStep(...) {
    IEcoEnumConnections* pEnum = 0;
    IEcoLab1Events* pIEvents = 0;

    // Получение перечислителя соединений
    pCMe->m_pISinkCP->pVTbl->EnumConnections(pCMe->m_pISinkCP, &pEnum);

    // Перебор всех подключенных sink'ов
    while (pEnum->pVTbl->Next(pEnum, 1, &cd, 0) == 0) {
        cd.pUnk->pVTbl->QueryInterface(cd.pUnk, &IID_IEcoLab1Events, &pIEvents);

        // Вызов события
        pIEvents->pVTbl->ShellSortStep(pIEvents, array, count, gap, current_index);

        pIEvents->pVTbl->Release(pIEvents);
        cd.pUnk->pVTbl->Release(cd.pUnk);
    }
}
```

## Схема подключения: один-к-одному

Текущая реализация демонстрирует схему **один приёмник - один подключаемый объект**:

- 1 компонент (CEcoLab1) с точкой подключения
- 1 приёмник (CEcoLab1Sink) для обработки событий
- 3 типа событий (OnBefore, Step, OnAfter)

## Выводы

1. **Connection Points успешно интегрированы** - механизм работает корректно
2. **События демонстрируют работу алгоритма** - каждый шаг Shell sort визуализируется
3. **Архитектура расширяема** - можно легко добавить новые типы событий
4. **Паттерн переиспользуем** - реализация может быть применена к другим алгоритмам
5. **Калькуляторы сохранены** - функциональность Lab2 остается доступной
